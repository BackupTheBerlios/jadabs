/**
 * <p>Performs static AOP by means of byte code instrumentation at load time of java classes<br>
 * Replaces any occurrence of a Constructor of any class in any component specified as dependency of
 * the component of the class being loaded by a static factory method of its proxy class</p>
 * 
 * Master thesis on Component Evolution in Distributed Ad-hoc Containers
 * @author tmicha@student.ethz.ch
 * 
 * {@linkplain http://www.csg.is.titech.ac.jp/~chiba/javassist/ javassist library homepage}
 * <p><code>ClassPool cp = ClassPool.getDefault();</code>
 * <code>CtClass point = cp.get("Point");</code><br>
 * <code>CtClass singleton = cp.get("Singleton");</code><br>
 * <code>CtClass client = cp.get("Client");</code><br>
 * <code>CodeConverter conv = new CodeConverter();</code><br>
 * <code>conv.replaceNew(point, singleton, "makePoint");</code><br>
 * <code>client.instrument(conv);</code><br>
 * </p><p>
 * This program substitutes "Singleton.makePoint()" 
 * for all occurrences of "new Point()" 
 * appearing in methods declared in a Client class. </p>
 * 
 */

package ch.ethz.iks.proxy;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CodeConverter;
import javassist.CtClass;
import javassist.NotFoundException;
import javassist.Translator;

import org.apache.log4j.Logger;

import ch.ethz.iks.evolution.cop.UpgradeableComponentResource;
import ch.ethz.iks.evolution.cop.UpgradeableComponentResourceFactory;
import ch.ethz.iks.jadabs.ComponentRepository;
import ch.ethz.iks.jadabs.IComponentResource;
import ch.ethz.iks.proxy.cop.ProxyComponentResource;
import ch.ethz.iks.proxy.cop.ProxyComponentResourceFactory;
import ch.ethz.iks.proxy.cop.ProxyLoader;

 
/**
 * Listens to loading of classes and uses bytecode instrumentation to manipulate ths bytecode at loadtime.
 * It replaces all invocations of constructors <code>new $TYPE ($AGRS)</code> 
 * within the code of the class that is passed to the <code>onWrite()</code> listener method invocations of the static factory method
 * <code>newExternalInstance($ARGS)</code> of the Wrapper class of $TYPE generated by <code>TransparentProxyFactory.newMigrationProxy()</code>. 
 * $TYPE denotes all external classes (all classes not in the same component as the loaded class but in the components dependencies).
 * $ARGS denotes the parameters passed to the constructor.
 * 
 * Master thesis on Component Evolution in Distributed Ad-hoc Containers
 * @author tmicha@student.ethz.ch
 */
public class ExternalReferenceScanner implements Translator {
	
	public ExternalReferenceScanner(String classpath, int version) {
		this.v = version;
		this.cp = classpath;
	}
	protected int v;
	protected String cp;
	
	/* (non-Javadoc)
	 * @see javassist.Translator#start(javassist.ClassPool)
	 */
	public void start(ClassPool pool)
		throws NotFoundException, CannotCompileException {
		//LOG.info(" inside start(): Translator was registered ");
	}
	
	private static Logger LOG = Logger.getLogger(ExternalReferenceScanner.class);
	private static int logCounter = 0;
	private static HashMap class2cop = new HashMap();
	private static HashMap cop2pool = new HashMap();

	/* (non-Javadoc)
	 * @see javassist.Translator#onWrite(javassist.ClassPool, java.lang.String)
	 */
	public void onWrite(ClassPool pool, String classname)
		throws NotFoundException, CannotCompileException {
		
		//LOG.info(++logCounter+" Searching component for "+classname+" in repository with #cop = "+ComponentRepository.Instance().getComponentResources().size());
		//  COMPONENT MUST HAVE BEEN PUT IN REPOSITORY MAP ALREADY (before initComponent())
		IComponentResource loadingCop = UpgradeableComponentResourceFactory.getComponentResourceByContent(classname);
		
		/* DEBUGGING ONLY: check if have to load from dependency: // MUST NOT happen: load from wrong cop!!!
		if (loadingCop == null) {
			LOG.error(cp+" "+v+": class "+classname+" belongs to no cop ");
			return;
		} else if( !((UpgradeableComponentResource)loadingCop).contains(classname))  {
			// wrong cop: hack , check for loadingCop.knowsClass(classname) instead 
			LOG.error(cp+" "+v+": class "+classname+" belongs not to cop "+loadingCop);
			return;
			
		}*/
		String cb = ProxyComponentResourceFactory.getProxyCodebase(loadingCop);
		IComponentResource proxyCop = ComponentRepository.Instance().getComponentResourceByCodebase(cb);
		if (proxyCop instanceof ProxyComponentResource) {
			// during an upgrade, check if current version of cop was retreived
			loadingCop = ((ProxyComponentResource)proxyCop).getOriginalComponent();
		} 
		
		//LOG.info(loadingCop+", "+loadingCop.getVersion()+": pool.get("+classname+")");
		//if (loadingCop instanceof ProxyComponentResource) return;
		
		int extRefCount = searchExternalReferences(classname, pool, loadingCop);
		if (extRefCount == 0) return;
		CtClass toManipulate = pool.get(classname);
		manipulate(classname, toManipulate, extRefCount);
		
	}
	
	
	protected void manipulate(String classname, CtClass toManipulate, int extRefCount) throws NotFoundException, CannotCompileException {
		//LOG.info(extRefCount+" Starting bytecode instrumentation... ");
		// replace all usages of constructors of the external classes found by a factory method of its proxy class (that may return a proxy instance instead).
		extRefCount = 0;
		Iterator extRefs = class2cop.entrySet().iterator();
		while (extRefs.hasNext()) {
			java.util.Map.Entry  entry = (java.util.Map.Entry) extRefs.next();
			UpgradeableComponentResource extCop =
				(UpgradeableComponentResource) entry.getValue();
			String extRef = (String) entry.getKey();
			LOG.info(extRefCount+"            ... hiding "+extRef+" in "+extCop.getCodeBase()+" from "+classname);
			String proxyName = null; 
			try {
				ClassPool externalPool = getPool(extCop);
				// create and load  a Proxy for external class extRefClass
				Class extRefClass = extCop.getClassLoader().loadClass(extRef);
				ProxyLoader proxyLoader = extCop.getProxyLoader();
				///ProxyFactory.setNamingConventionOfWrapper(ProxyFactory.proxyJarPrefix, true);
				Class proxyClass = TransparentProxyFactory.getProxyClass(proxyLoader, extRefClass); // creates the proxy class for the external class
				proxyName = proxyClass.getName();
				//LOG.info(extRefCount+" Created proxy class "+proxyName+" for externally referenced class "+extRef);
				instrument(toManipulate, extRef, externalPool, proxyName, proxyLoader);
			}
			catch (ClassNotFoundException e) {
				LOG.error(extRefCount+" onWrite: Caught ClassNotFoundException "+e.getException());
			} catch (WrappingException w) {
				LOG.error(extRef,w);
			} finally { extRefCount++;}
		}
	}

	// TODO: Implement byte code instrumentation to replace calls to methods that do not exist in proxy by invoke(callee,methodHash/methodName,args)
	protected void instrument(CtClass toManipulate, String extRef, ClassPool externalPool, String proxyName, ProxyLoader loader) throws NotFoundException, CannotCompileException {
		ClassPool proxyPool = getPool(externalPool, loader);
		// javassist bytecode manipulation
		
		//LOG.info(" onWrite: getting proxy "+proxyName+" from pool "+loader.getClassPath());
		CtClass proxyCtClass = proxyPool.get(proxyName);
		//LOG.info(" onWrite: getting external class "+extRef+" from pool "+extCop.getClassPath());
		CtClass extRefCtClass = externalPool.get(extRef);
		if (proxyCtClass.getSuperclass() == extRefCtClass) {
			CodeConverter conv = new CodeConverter();
			
			conv.replaceNew(
				extRefCtClass,
				proxyCtClass,
				TransparentProxyFactory.factoryMethod);
			// replace any occurence of "new $extRefClass ()" by "$proxyClass.$factoryMathod" in code of $className
			toManipulate.instrument(conv);
			// e.g. "new TestComponentMain()" is replaced by "Proxy4_TestComponentMain.newExternalInstance()" in bytecode of class "ComponentUsingAnotherOne"
			//LOG.info(" Finished bytecode instrumentation of "+toManipulate.getName());
		}
	}

	protected ClassPool getPool(ClassPool externalPool, ProxyLoader loader) throws NotFoundException {
		ClassPool proxyPool;
		//TODO Cheating here by mapping the ProxyLoader instead of the ProxyResource. But have to change that as soon as ProxyResource initCL() sets ProxyLoader itself
		Object cached = cop2pool.get(loader);
		if (cached instanceof ClassPool) {
			proxyPool = (ClassPool) cached;
		} else {
			proxyPool = ClassPool.getDefault();
			proxyPool.appendClassPath(loader.getClassPath());
			cop2pool.put(loader, externalPool);
		}
		return proxyPool;
	}

	protected ClassPool getPool(UpgradeableComponentResource extCop) throws NotFoundException {
		//	create a pool for every dependency component with external classes
		ClassPool externalPool;
		Object cached = cop2pool.get(extCop);
		if (cached instanceof ClassPool) {
			externalPool = (ClassPool) cached;
		} else {
			externalPool = ClassPool.getDefault();
			String path = extCop.getExtResLocation()+extCop.getCodeBase();
			externalPool.appendClassPath(path);
			//LOG.info(" Creating a ClassPool for dependency Component at "+path);
			cop2pool.put(extCop, externalPool);
		}
		return externalPool;
	}

	/**
	 * looks for classes that are referenced within the code of the class named <code>classname</code> that do neither
	 * belong to system classes nor to the same component as the class searched. Any external reference found must
	 * belong to a dependency component of the component of the class being searched.
	 * For each occurrence of such an external reference, <code>foundExternalReference</code> is invoked.
	 * 
	 * @param classname
	 * @param pool
	 * @param loadingCop
	 * @return
	 */
	protected int searchExternalReferences(String classname, ClassPool pool, IComponentResource loadingCop) {
				//		LOG.info(logCounter+"                     found it ... in pool "+loadingCop.getExtResLocation() + loadingCop.getCodeBase());
			  //search for external references in code of class "className" using CtClass.getRefClasses() and create an externalPool for each cop in dependencies 
			  CtClass toSearch = null;
			try {
				//LOG.info(cp+" "+v+": searching for external references in "+classname);
				toSearch = pool.get(classname);
				
				CtClass [] ifcs = toSearch.getInterfaces();
				CtClass superClass = toSearch.getSuperclass();
				
			
			} catch (IllegalStateException e) {
				LOG.error("Zipfile is not open",e); 
			} catch (NotFoundException e) {
				LOG.error("javassist.NotFoundException: class "+classname+" not found in "+cp+" "+v);
				
				throw new RuntimeException();// loadClassBytes fails -> loadFromDep
			} 
			Vector externalClasses = new Vector();
			  Iterator referencedClasses = toSearch.getRefClasses().iterator();
			  int extRefCount = 0;
			  while (referencedClasses.hasNext()) {
				  String toWrap = (String) referencedClasses.next();
				  IComponentResource dependencyCop;
				  Object cached = class2cop.get(toSearch.getName());
				  if ( cached instanceof UpgradeableComponentResource) {
					  dependencyCop = (UpgradeableComponentResource) cached;
				  } else { 
					  dependencyCop = UpgradeableComponentResourceFactory.getComponentResourceByContent(toWrap);
				  }
				  if ((dependencyCop instanceof UpgradeableComponentResource) && (!loadingCop.getCodeBase().equals(dependencyCop.getCodeBase())) ) { // compare jar names (different versions are considered equal: java.** and internal Classes seems to be external of new cop version (found inside old cop version))
					  // a dependency that may be uncoupled has been found
					  // dependency is ignored if the dependency class is already hidden behind a proxy
					  // or the dependency class may be in use already or the dependency class lies in a previous version of the loading cop
					  //LOG.info("Found dependency to external class "+toWrap+" in cop "+dependencyCop+" while loading class "+toSearch.getName()+" in cop "+loadingCop);
					  
					  foundExternalReference(loadingCop, toWrap, (UpgradeableComponentResource)dependencyCop);
					  
					  extRefCount++;
				  } else {
				  	//if (dependencyCop == null) LOG.error("Nullpointer, dependencyCop is null (system class?)");
					//else if (dependencyCop != loadingCop) LOG.info("dependency is NOT evolvable "+dependencyCop.getCodeBase()+" : "+dependencyCop.getClass().getName());
				  }
			  }
			  //LOG.info(logCounter+" onWrite: Found "+extRefCount+" external reference(s) in "+loadingCop.getCodeBase()+"."+classname);
		return extRefCount;
	}


	protected void foundExternalReference(IComponentResource insideCop, String externalClassName, UpgradeableComponentResource copOfExternalClass) {
		  class2cop.put(externalClassName, copOfExternalClass);
	}
	
	public static void clearCaches() {
		ExternalReferenceScanner.cop2pool.clear();
		ExternalReferenceScanner.class2cop.clear();
	}

}
