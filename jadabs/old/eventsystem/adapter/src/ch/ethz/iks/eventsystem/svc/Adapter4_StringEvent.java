package ch.ethz.iks.eventsystem.svc;import org.apache.log4j.Logger;import ch.ethz.iks.eventsystem.IEvent;import ch.ethz.iks.evolution.adapter.DefaultAdapter;import ch.ethz.iks.jxme.IMessage;import ch.ethz.iks.proxy.TransparentProxyFactory;/** * Custom adapter for StringEvent class (v1 or v3 compatible).  * Maps invocations from the transparent proxy to the current version of StringEvent implementation. This adapter supports the mapping * of kind <code>hash</code> for a few methods as specified by the <code>-adapt hash</code> command line * argument as well as full support for the <code>name</code> kind. * => component adapter2_escop/ for sample evolution of escop *  * Master thesis on Component Evolution in Distributed Ad-hoc Containers * @author tmicha@student.ethz.ch */public class Adapter4_StringEvent extends DefaultAdapter {	public Adapter4_StringEvent() {            super();    }	private static final Class adaptee = StringEvent.class;    	// constants representing the methods of the proxy and the adaptee object   	private static final int METHOD_SETMASTERPEERNAME = TransparentProxyFactory.getMethodHash(adaptee, "setMasterPeerName",new Class[] {String.class});	private static final int METHOD_GETSLAVEPEERNAME = TransparentProxyFactory.getMethodHash(adaptee, "getSlavePeerName", null);	private static final int METHOD_TOMESSAGE = TransparentProxyFactory.getMethodHash(adaptee, "toMessage", new Class [] {Class.class});	private static final int METHOD_TOSTRING = TransparentProxyFactory.getMethodHash(adaptee, "toString", null);	private static final int METHOD_TOXMLSTRING = TransparentProxyFactory.getMethodHash(adaptee, "toXMLString", null);		private static Logger LOG = Logger.getLogger(Adapter4_StringEvent.class);		/**	 * adapts the invocation on the proxy of a InQueue object to the hidden implementation.	 * Uses the <code>hash</code> kind signature to match from the proxy method to the method of	 * the hidden object. 	 * 	 * TODO: finish implementation by adapting methods other than setMasterPeerName, getSlavePeerName, toMessage, toString	 * 	 * This implementation maps by just forwarding the invocations on the proxy to the associated hidden object	 */		protected Object adapt(Object callee, int methodCode, Object [] args) throws Throwable {		if (methodCode == METHOD_SETMASTERPEERNAME) {			((StringEvent) callee).setMasterPeerName( (String)args[0]);			return null;		} else if (methodCode == METHOD_GETSLAVEPEERNAME) {			return ((StringEvent) callee).getSlavePeerName();		} else if (methodCode == METHOD_TOMESSAGE) {			return ((StringEvent) callee).toMessage( (Class) args[0]);		} else if (methodCode == METHOD_TOSTRING) {			return callee.toString();		}else if (methodCode == METHOD_TOXMLSTRING) {			return ((IEvent)callee).toXMLString();				} else {			throw new NoSuchMethodException("unknown method hash: "+methodCode);		}	}    	/**	 * adapts the invocation on the proxy of a InQueue object to the hidden implementation.	 * Uses the <code>name</code> kind signature to match from the proxy method to the method of	 * the hidden object. 	 * 	 * This implementation maps by just forwarding the invocations on the proxy to the associated hidden object	 */		protected Object adapt(Object callee, String methodName, Object [] args) throws Throwable {		if (methodName.equals("toMessage")) {			return ((StringEvent) callee).toMessage( (Class)args[0]);					} else if (methodName.equals("getID")) {			return ((StringEvent) callee).getID();		} else if (methodName.equals("getTag")) {			return ((StringEvent) callee).getTag();		} else if (methodName.equals("setTag")) {			((StringEvent) callee).setTag( (String)args[0] );			return null;		} else if (methodName.equals("getValue")) {			return ((StringEvent) callee).getValue();		} else if (methodName.equals("addAttribute")) {			((StringEvent) callee).addAttribute( args[0], args[1] );			return null;		} else if (methodName.equals("getAttributeValue")) {			return ((StringEvent) callee).getAttributeValue( args[0] );		} else if (methodName.equals("getAttributes")) {			return ((StringEvent) callee).getAttributes();		} else if (methodName.equals("removeAttributeValue")) {			 ((StringEvent) callee).removeAttributeValue( args[0] );			 return null;		} else if (methodName.equals("setMasterPeerName")) {			((StringEvent) callee).setMasterPeerName( (String)args[0] );			return null;		} else if (methodName.equals("setSlavePeerName")) {			((StringEvent) callee).setSlavePeerName( (String)args[0] );			return null;		}  else if (methodName.equals("getMasterPeerName")) {			return ((StringEvent) callee).getMasterPeerName();		} else if (methodName.equals("getSlavePeerName")) {			return ((StringEvent) callee).getSlavePeerName();		} else if (methodName.equals("init")) {			((StringEvent) callee).init( (IMessage) args[0]);			return null;		} else if (methodName.equals("toXMLString")) {			return ((StringEvent) callee).toXMLString();		} else if (methodName.equals("clone")) {			((StringEvent) callee).clone();			return null;		} else if (methodName.equals("toString")) {			return callee.toString();					} else {			throw new NoSuchMethodException(methodName);		}	}		protected Object adaptStatic(String methodName, Object [] args) throws Throwable {		return null;	}}